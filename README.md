# messagematch

message match expresses a specification for a JSON formatted message. It is designed to be used to match against messages generated by a system AND to generate messages for input into downstream systems, forming the contract between them.

In general it looks like a regular JSON message with some special matching keys/values as defined below. JSON in the spec that does not use any special matching is "basic" json.



## Matching

For basic json the actual and expected are expected to be exact matches except 
 - keys in JSON objects are allowed to appear in any order
 - extra keys in actual value objects are ingored
 - extra values in json arrays are skipped and ignored
The matching behaviour can be altered by using matchers. A matcher is a value or key starting with '$' e.g. `"value" : "$Int"` will match with `"value" : "5"` or `"value" : 5`

A "basic" value that starts with $ can be escaped using '\'s e.g. `"dollarValue" : "\\$100"`

## Generation

In input generating mode basic json is reproduced exactly.

For the value based matchers the matcher expression can be followed with a comma and a prototype value that will be used in the generated message e.g. `"value" : "$Int,5"` will generate `"value" : 5`.


The structural type matchers (see below) are simply removed

## types of matcher

### Primitive values

#### type based
Matches any value of the appropriate primitive type. Numeric types are not subjected to upper and lower bounds e.g. $Int matches fine with 1000000000000000000000. If no value is supplied then a default will be used of 0, 0.0 or "" when generating
 - $Int - any json integer e.g. `"value" : "$Int"` will match `"value" : 5` but will generate `"value" : 0` as no default was supplied
 - $Num - any json numeric value
 - $String - any json string value
 
#### regexp
Matches based on a RegEx. The regex is delimited using '^' at the beginning and end. '^'s appearing inside the regex need be escaped. The regex must be followed with a defualt value to be used for generation.

E.g. `"value" : "$^[\\^0-9]*^,abc" ` will match against any string not containing a digit and will generate `"value" : "abc"`


### bounds
A value can be comparend relative to a given value  using <,>, >=,<= or +-. the +- opertor is used to specify a value should be within a given margin of the centre value. The values are always treated as decimals.
E.g. 
 - `"Value" : "$<5"` matches values less than 5
 - `"Value" :"$+-(1.2,0.1)"` matches values between 1.1 and 1.3 (inclusive)
 
 When generating for +- the given centre value is used.<br>
 For the closed comparators >= and <= the given value is generated.<br>
 For the open comparators >  and < the value has 1 added or subtracted from it;

#### binding
A value can be *bound* using *=name* to create constraints within a json document. E.g.
```
{ 
	"value1" : "$Int=myVar , 6",
	"value2" : "$>5=myVar"
}
'''
will ensure that the value1 and value2 have the same value, it is an integer and it is > 5

When generating the same value will be used for both. E.g. in the example above we would generate `{	"value1" : 6,"value2" : 6 }`. If a default value has not been supplied (or a "bad" value is provided) such that the first appearance generates a value that then fails a later constraint an error will be thrown at generation time. E.g. if no default had been supplied for the value of "value1" it would have generated the default integer of 0. This would violate the constraint on "value2" and result in an error;

//TODO already bound variable syntax
A variable that has already been bound earlier in a document can be used as a value in an expression. If it has not been bound before being used in this way it will be a match failure. E.g.
```
{ 
	"value1" : "$Int=myVar , 6",
	"value2" : "$>$myVar"
}
'''
will match if "value2" is > "value1".

When generating the bound value will be generated by the usual rules, e.g. in the example above  we would generate `{	"value1" : 6,"value2" : 7 }`

#### date/time based




### plugable

### Structural Values

#### "strict" mode

#### list (/map) value count

### unordered list